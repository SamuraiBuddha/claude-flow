-- SpecKit Integration SQLite Database Schema
-- Stores specifications, implementation plans, tasks, and artifact lineage for SDD workflow
-- Version: 1.0.0

-- Enable foreign keys
PRAGMA foreign_keys = ON;

-- ============================================================================
-- SPECIFICATIONS TABLE
-- Stores feature specifications generated by /speckit.specify command
-- ============================================================================
CREATE TABLE IF NOT EXISTS specifications (
    spec_id TEXT PRIMARY KEY,
    feature_name TEXT NOT NULL,
    feature_branch TEXT NOT NULL,
    user_stories TEXT NOT NULL,          -- JSON array of user stories with priorities
    requirements TEXT NOT NULL,          -- JSON object: { functional: [], entities: [] }
    acceptance_criteria TEXT NOT NULL,   -- JSON array of acceptance scenarios
    success_criteria TEXT,               -- JSON array of measurable outcomes
    edge_cases TEXT,                     -- JSON array of edge case descriptions
    status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'review', 'approved', 'implemented', 'deprecated')),
    created_by_agent TEXT NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    version TEXT NOT NULL DEFAULT '1.0',
    parent_version_id TEXT,              -- For version tracking
    spec_source_path TEXT,               -- Path to spec.md file
    raw_markdown TEXT,                   -- Original markdown content
    metadata TEXT,                       -- JSON metadata
    FOREIGN KEY (parent_version_id) REFERENCES specifications(spec_id) ON DELETE SET NULL
);

-- ============================================================================
-- IMPLEMENTATION_PLANS TABLE
-- Stores implementation plans generated by /speckit.plan command
-- ============================================================================
CREATE TABLE IF NOT EXISTS implementation_plans (
    plan_id TEXT PRIMARY KEY,
    spec_id TEXT NOT NULL,
    tech_stack TEXT NOT NULL,            -- JSON: { language, dependencies, storage, testing, platform }
    architecture_decisions TEXT NOT NULL, -- JSON array of architectural decisions with rationale
    research_findings TEXT,              -- JSON: research.md parsed content
    constitution_gates TEXT NOT NULL,    -- JSON: { simplicity_gate, anti_abstraction_gate, integration_gate }
    data_models TEXT,                    -- JSON: data-model.md parsed content
    contracts TEXT,                      -- JSON array of API contracts from contracts/ directory
    project_structure TEXT,              -- JSON: directory structure specification
    complexity_tracking TEXT,            -- JSON: violations and justifications
    quickstart_scenarios TEXT,           -- JSON: validation scenarios from quickstart.md
    generated_by TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'review', 'approved', 'in_progress', 'completed')),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    plan_source_path TEXT,               -- Path to plan.md file
    raw_markdown TEXT,                   -- Original markdown content
    metadata TEXT,                       -- JSON metadata
    FOREIGN KEY (spec_id) REFERENCES specifications(spec_id) ON DELETE CASCADE
);

-- ============================================================================
-- TASK_REGISTRY TABLE
-- Stores tasks generated by /speckit.tasks command
-- ============================================================================
CREATE TABLE IF NOT EXISTS task_registry (
    task_id TEXT PRIMARY KEY,            -- Format: T001, T002, etc.
    plan_id TEXT NOT NULL,
    story_id TEXT,                       -- Reference to user story (US1, US2, etc.)
    phase TEXT NOT NULL,                 -- Setup, Foundational, UserStory1, Polish, etc.
    description TEXT NOT NULL,
    dependencies TEXT,                   -- JSON array of task_ids this depends on
    parallelizable INTEGER NOT NULL DEFAULT 0,  -- Boolean: can run in parallel
    file_paths TEXT,                     -- JSON array of files to create/modify
    assigned_agent TEXT,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'in_progress', 'completed', 'blocked', 'skipped')),
    test_scenarios TEXT,                 -- JSON array of test scenarios for this task
    priority INTEGER NOT NULL DEFAULT 0, -- Higher = more important
    estimated_effort TEXT,               -- e.g., "small", "medium", "large"
    actual_start_at TIMESTAMP,
    actual_end_at TIMESTAMP,
    output_artifacts TEXT,               -- JSON array of generated artifact paths
    notes TEXT,                          -- Agent notes/observations
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    metadata TEXT,                       -- JSON metadata
    FOREIGN KEY (plan_id) REFERENCES implementation_plans(plan_id) ON DELETE CASCADE
);

-- ============================================================================
-- ARTIFACT_LINEAGE TABLE
-- Tracks relationships between artifacts for cascade detection
-- ============================================================================
CREATE TABLE IF NOT EXISTS artifact_lineage (
    id TEXT PRIMARY KEY,
    artifact_type TEXT NOT NULL CHECK (artifact_type IN (
        'specification', 'plan', 'task', 'data_model', 'contract',
        'test', 'implementation', 'research', 'quickstart'
    )),
    artifact_id TEXT NOT NULL,           -- Reference to the artifact
    source_artifact_id TEXT,             -- What this was derived from
    source_artifact_type TEXT,           -- Type of source artifact
    derived_artifacts TEXT,              -- JSON array of { type, id } objects
    generation_timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    generating_agent TEXT NOT NULL,
    validation_status TEXT NOT NULL DEFAULT 'pending' CHECK (validation_status IN ('pending', 'valid', 'invalid', 'stale')),
    invalidated_at TIMESTAMP,            -- When artifact became stale
    invalidation_reason TEXT,            -- Why it became stale
    file_path TEXT,                      -- Physical file location
    content_hash TEXT,                   -- SHA-256 hash for change detection
    metadata TEXT                        -- JSON metadata
);

-- ============================================================================
-- CONSTITUTIONAL_COMPLIANCE TABLE
-- Tracks constitutional gate compliance and exceptions
-- ============================================================================
CREATE TABLE IF NOT EXISTS constitutional_compliance (
    id TEXT PRIMARY KEY,
    gate_name TEXT NOT NULL CHECK (gate_name IN (
        'simplicity_gate', 'anti_abstraction_gate', 'integration_gate',
        'library_first', 'cli_interface', 'test_first'
    )),
    status TEXT NOT NULL CHECK (status IN ('passed', 'failed', 'exception_granted')),
    artifact_id TEXT NOT NULL,           -- Which artifact this applies to
    artifact_type TEXT NOT NULL,         -- Type of artifact (plan, implementation, etc.)
    check_details TEXT,                  -- JSON: specific checks performed
    reason_for_exception TEXT,           -- If exception_granted, why
    exception_justification TEXT,        -- Detailed justification for exception
    simpler_alternative_rejected TEXT,   -- What simpler approach was considered
    approved_by_agent TEXT,
    approved_at TIMESTAMP,
    expires_at TIMESTAMP,                -- Exception may have expiry
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    metadata TEXT                        -- JSON metadata
);

-- ============================================================================
-- SPEC_VERSIONS TABLE
-- Dedicated version tracking for specifications
-- ============================================================================
CREATE TABLE IF NOT EXISTS spec_versions (
    version_id TEXT PRIMARY KEY,
    spec_id TEXT NOT NULL,
    version_number TEXT NOT NULL,        -- Semantic version: 1.0, 1.1, 2.0
    version_type TEXT NOT NULL CHECK (version_type IN ('major', 'minor', 'patch')),
    change_summary TEXT NOT NULL,        -- Brief description of changes
    changed_sections TEXT,               -- JSON array of section names that changed
    diff_from_previous TEXT,             -- JSON diff from previous version
    breaking_changes INTEGER NOT NULL DEFAULT 0,  -- Boolean
    affected_downstream TEXT,            -- JSON: { plans: [], tasks: [] } that need regeneration
    created_by_agent TEXT NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    metadata TEXT,
    FOREIGN KEY (spec_id) REFERENCES specifications(spec_id) ON DELETE CASCADE
);

-- ============================================================================
-- USER_STORIES TABLE
-- Normalized user stories for better querying
-- ============================================================================
CREATE TABLE IF NOT EXISTS user_stories (
    story_id TEXT PRIMARY KEY,           -- Format: US1, US2, etc.
    spec_id TEXT NOT NULL,
    title TEXT NOT NULL,
    priority TEXT NOT NULL,              -- P1, P2, P3, etc.
    description TEXT NOT NULL,
    why_priority TEXT,                   -- Explanation for priority level
    independent_test TEXT,               -- How to test independently
    acceptance_scenarios TEXT NOT NULL,  -- JSON array of Given/When/Then
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'in_progress', 'completed', 'blocked')),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (spec_id) REFERENCES specifications(spec_id) ON DELETE CASCADE
);

-- ============================================================================
-- CONTRACTS TABLE
-- Stores API contracts from contracts/ directory
-- ============================================================================
CREATE TABLE IF NOT EXISTS contracts (
    contract_id TEXT PRIMARY KEY,
    plan_id TEXT NOT NULL,
    contract_type TEXT NOT NULL CHECK (contract_type IN ('rest', 'websocket', 'graphql', 'grpc', 'event')),
    name TEXT NOT NULL,
    description TEXT,
    endpoints TEXT NOT NULL,             -- JSON array of endpoint definitions
    request_schema TEXT,                 -- JSON Schema for requests
    response_schema TEXT,                -- JSON Schema for responses
    error_responses TEXT,                -- JSON array of error responses
    source_file TEXT,                    -- Original contract file path
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    metadata TEXT,
    FOREIGN KEY (plan_id) REFERENCES implementation_plans(plan_id) ON DELETE CASCADE
);

-- ============================================================================
-- INDEXES
-- ============================================================================

-- Specifications indexes
CREATE INDEX IF NOT EXISTS idx_specs_feature_name ON specifications(feature_name);
CREATE INDEX IF NOT EXISTS idx_specs_status ON specifications(status);
CREATE INDEX IF NOT EXISTS idx_specs_created_by ON specifications(created_by_agent);
CREATE INDEX IF NOT EXISTS idx_specs_feature_branch ON specifications(feature_branch);
CREATE INDEX IF NOT EXISTS idx_specs_version ON specifications(version);

-- Implementation plans indexes
CREATE INDEX IF NOT EXISTS idx_plans_spec ON implementation_plans(spec_id);
CREATE INDEX IF NOT EXISTS idx_plans_status ON implementation_plans(status);
CREATE INDEX IF NOT EXISTS idx_plans_generated_by ON implementation_plans(generated_by);

-- Task registry indexes
CREATE INDEX IF NOT EXISTS idx_tasks_plan ON task_registry(plan_id);
CREATE INDEX IF NOT EXISTS idx_tasks_story ON task_registry(story_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON task_registry(status);
CREATE INDEX IF NOT EXISTS idx_tasks_phase ON task_registry(phase);
CREATE INDEX IF NOT EXISTS idx_tasks_assigned ON task_registry(assigned_agent);
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON task_registry(priority DESC);

-- Artifact lineage indexes
CREATE INDEX IF NOT EXISTS idx_lineage_type ON artifact_lineage(artifact_type);
CREATE INDEX IF NOT EXISTS idx_lineage_artifact ON artifact_lineage(artifact_id);
CREATE INDEX IF NOT EXISTS idx_lineage_source ON artifact_lineage(source_artifact_id);
CREATE INDEX IF NOT EXISTS idx_lineage_status ON artifact_lineage(validation_status);
CREATE INDEX IF NOT EXISTS idx_lineage_timestamp ON artifact_lineage(generation_timestamp);

-- Constitutional compliance indexes
CREATE INDEX IF NOT EXISTS idx_compliance_gate ON constitutional_compliance(gate_name);
CREATE INDEX IF NOT EXISTS idx_compliance_status ON constitutional_compliance(status);
CREATE INDEX IF NOT EXISTS idx_compliance_artifact ON constitutional_compliance(artifact_id);

-- Spec versions indexes
CREATE INDEX IF NOT EXISTS idx_versions_spec ON spec_versions(spec_id);
CREATE INDEX IF NOT EXISTS idx_versions_number ON spec_versions(version_number);
CREATE INDEX IF NOT EXISTS idx_versions_type ON spec_versions(version_type);

-- User stories indexes
CREATE INDEX IF NOT EXISTS idx_stories_spec ON user_stories(spec_id);
CREATE INDEX IF NOT EXISTS idx_stories_priority ON user_stories(priority);
CREATE INDEX IF NOT EXISTS idx_stories_status ON user_stories(status);

-- Contracts indexes
CREATE INDEX IF NOT EXISTS idx_contracts_plan ON contracts(plan_id);
CREATE INDEX IF NOT EXISTS idx_contracts_type ON contracts(contract_type);

-- ============================================================================
-- TRIGGERS
-- ============================================================================

-- Update timestamp on specifications modification
CREATE TRIGGER IF NOT EXISTS update_specs_timestamp
AFTER UPDATE ON specifications
BEGIN
    UPDATE specifications SET updated_at = CURRENT_TIMESTAMP WHERE spec_id = NEW.spec_id;
END;

-- Update timestamp on implementation plans modification
CREATE TRIGGER IF NOT EXISTS update_plans_timestamp
AFTER UPDATE ON implementation_plans
BEGIN
    UPDATE implementation_plans SET updated_at = CURRENT_TIMESTAMP WHERE plan_id = NEW.plan_id;
END;

-- Update timestamp on task registry modification
CREATE TRIGGER IF NOT EXISTS update_tasks_timestamp
AFTER UPDATE ON task_registry
BEGIN
    UPDATE task_registry SET updated_at = CURRENT_TIMESTAMP WHERE task_id = NEW.task_id;
END;

-- Update timestamp on user stories modification
CREATE TRIGGER IF NOT EXISTS update_stories_timestamp
AFTER UPDATE ON user_stories
BEGIN
    UPDATE user_stories SET updated_at = CURRENT_TIMESTAMP WHERE story_id = NEW.story_id;
END;

-- Update timestamp on contracts modification
CREATE TRIGGER IF NOT EXISTS update_contracts_timestamp
AFTER UPDATE ON contracts
BEGIN
    UPDATE contracts SET updated_at = CURRENT_TIMESTAMP WHERE contract_id = NEW.contract_id;
END;

-- ============================================================================
-- VIEWS
-- ============================================================================

-- Active specifications with plan and task counts
CREATE VIEW IF NOT EXISTS active_specifications AS
SELECT
    s.*,
    COUNT(DISTINCT p.plan_id) as plan_count,
    COUNT(DISTINCT t.task_id) as task_count,
    SUM(CASE WHEN t.status = 'completed' THEN 1 ELSE 0 END) as completed_tasks
FROM specifications s
LEFT JOIN implementation_plans p ON s.spec_id = p.spec_id
LEFT JOIN task_registry t ON p.plan_id = t.plan_id
WHERE s.status NOT IN ('deprecated')
GROUP BY s.spec_id;

-- Task progress by story
CREATE VIEW IF NOT EXISTS task_progress_by_story AS
SELECT
    t.story_id,
    us.title as story_title,
    us.priority,
    COUNT(*) as total_tasks,
    SUM(CASE WHEN t.status = 'completed' THEN 1 ELSE 0 END) as completed,
    SUM(CASE WHEN t.status = 'in_progress' THEN 1 ELSE 0 END) as in_progress,
    SUM(CASE WHEN t.status = 'blocked' THEN 1 ELSE 0 END) as blocked,
    ROUND(100.0 * SUM(CASE WHEN t.status = 'completed' THEN 1 ELSE 0 END) / COUNT(*), 2) as completion_percentage
FROM task_registry t
LEFT JOIN user_stories us ON t.story_id = us.story_id
WHERE t.story_id IS NOT NULL
GROUP BY t.story_id;

-- Artifact dependency graph
CREATE VIEW IF NOT EXISTS artifact_dependencies AS
SELECT
    al.id,
    al.artifact_type,
    al.artifact_id,
    al.source_artifact_type,
    al.source_artifact_id,
    al.validation_status,
    al.generation_timestamp,
    CASE
        WHEN al.validation_status = 'stale' THEN 'needs_regeneration'
        WHEN al.validation_status = 'invalid' THEN 'needs_fix'
        ELSE 'ok'
    END as action_required
FROM artifact_lineage al;

-- Constitutional compliance overview
CREATE VIEW IF NOT EXISTS compliance_overview AS
SELECT
    gate_name,
    COUNT(*) as total_checks,
    SUM(CASE WHEN status = 'passed' THEN 1 ELSE 0 END) as passed,
    SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failed,
    SUM(CASE WHEN status = 'exception_granted' THEN 1 ELSE 0 END) as exceptions,
    ROUND(100.0 * SUM(CASE WHEN status = 'passed' THEN 1 ELSE 0 END) / COUNT(*), 2) as pass_rate
FROM constitutional_compliance
GROUP BY gate_name;

-- Latest spec versions
CREATE VIEW IF NOT EXISTS latest_spec_versions AS
SELECT
    s.spec_id,
    s.feature_name,
    s.version as current_version,
    sv.version_number as latest_recorded_version,
    sv.change_summary as last_change,
    sv.created_at as last_version_date,
    sv.breaking_changes
FROM specifications s
LEFT JOIN spec_versions sv ON s.spec_id = sv.spec_id
WHERE sv.version_id IS NULL OR sv.created_at = (
    SELECT MAX(sv2.created_at) FROM spec_versions sv2 WHERE sv2.spec_id = s.spec_id
);

-- ============================================================================
-- INITIAL DATA
-- ============================================================================

INSERT OR IGNORE INTO constitutional_compliance (id, gate_name, status, artifact_id, artifact_type, created_at)
SELECT 'system_init', 'simplicity_gate', 'passed', 'system', 'system', CURRENT_TIMESTAMP
WHERE NOT EXISTS (SELECT 1 FROM constitutional_compliance WHERE id = 'system_init');
